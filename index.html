<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Grid UI System</title>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            background: linear-gradient(135deg, #8b7d6b 0%, #a69a8a 30%, #c0b5a3 60%, #d4c5b9 100%);
            min-height: 100vh;
            display: flex;
            color: var(--text);
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'JetBrains Mono', 'Fira Code', 'Consolas', monospace;
            font-size: 28px;
        }

        :root {
            --bg: #8b7d6b;
            --surface: #c9b79c;
            --surface-light: #d4c5b9;
            --text: #4a4035;
            --text-muted: #6b5d4f;
            --accent: #7a8c7a;
            --accent-hover: #8fa28f;
            --success: #a8b2a1;
            --error: #c47e6a;
            --border: #9b8f7f;

            /* Grid Colors */
            --grid-cell-base: rgba(122, 140, 122, 0.05);
            --grid-cell-border: rgba(143, 162, 143, 0.2);
            --grid-cell-hover: rgba(203, 166, 247, 0.4);
        }

        /* Game Grid System */
        .game-grid-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 0;
        }

        .game-grid {
            display: grid;
            width: 100vw;
            height: 100vh;
            gap: 1px;
            background: rgba(0, 0, 0, 0.1);
        }

        .grid-cell {
            background: var(--grid-cell-base);
            border: 1px solid var(--grid-cell-border);
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.3);
            transition: all 0.2s ease;
        }

        .grid-cell:hover {
            background: var(--grid-cell-hover);
            color: rgba(255, 255, 255, 0.8);
        }

        /* UI Component Base Styles */
        .ui-component {
            box-sizing: border-box;
        }

        /* Component Level Management */
        .ui-level-0 { z-index: 1000; }
        .ui-level-1 { z-index: 1100; }
        .ui-level-2 { z-index: 1200; }
        .ui-level-3 { z-index: 1300; }
        .ui-level-4 { z-index: 1400; }
        .ui-level-5 { z-index: 1500; }

        /* Auth Container Styles */
        .auth-container {
            background: #d4c5b9;
            border: 2px solid var(--text);
            box-shadow: 0 0 15px var(--accent);
            border-radius: 4px;
            padding: 20px;
            min-width: 400px;
            min-height: 400px;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: grid;
            grid-template-columns: repeat(20, 1fr);
            grid-template-rows: repeat(20, 1fr);
            gap: 0;
        }
        
        /* Distinct containers for clarity */
        .auth-unauthenticated {
            border-color: var(--text);
            box-shadow: 0 0 15px var(--accent);
        }
        
        .auth-authenticated {
            /* Remove all visual styling - transparent container */
            background: transparent;
            border: none;
            box-shadow: none;
            padding: 0;
            min-width: auto;
            min-height: auto;
            top: auto;
            bottom: 0;
            left: 0;
            right: 0;
            transform: none;
            width: 100%;
            height: auto;
            display: block;
        }
        
        /* Chat UI Styles */
        .chat-ui {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 300px;
            background: var(--surface);
            border-top: 2px solid var(--border);
            display: flex;
            flex-direction: column;
            font-family: 'JetBrains Mono', 'Fira Code', 'Consolas', monospace;
        }
        
        .chat-header {
            background: var(--surface-light);
            padding: 10px 20px;
            border-bottom: 1px solid var(--border);
            color: var(--text);
            font-size: 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .chat-logout-btn {
            padding: 4px 12px;
            font-size: 12px;
            background: var(--error);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-family: inherit;
            transition: background 0.2s;
        }
        
        .chat-logout-btn:hover {
            background: #d45e4a;
        }
        
        .chat-messages {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        
        .chat-message {
            max-width: 70%;
            padding: 8px 12px;
            border-radius: 12px;
            font-size: 14px;
            line-height: 1.4;
            word-wrap: break-word;
        }
        
        .chat-message.user {
            background: var(--accent);
            color: white;
            align-self: flex-end;
            border-bottom-right-radius: 4px;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
        }
        
        .chat-message.system {
            background: var(--surface-light);
            color: var(--text);
            align-self: flex-start;
            font-style: italic;
            border-bottom-left-radius: 4px;
        }
        
        .chat-message .sender {
            font-weight: bold;
            font-size: 12px;
            margin-bottom: 2px;
            opacity: 0.9;
        }
        
        .chat-message .content {
            font-size: 14px;
            line-height: 1.4;
        }
        
        .chat-message .timestamp {
            font-size: 10px;
            opacity: 0.7;
            margin-top: 2px;
        }
        
        .chat-message.system .timestamp {
            font-size: 11px;
            text-align: left;
            width: 100%;
            display: block;
            margin-top: 4px;
        }
        
        .chat-input-container {
            display: flex;
            padding: 10px;
            border-top: 1px solid var(--border);
            background: var(--surface);
            gap: 10px;
        }
        
        .chat-input {
            flex: 1;
            padding: 10px;
            background: var(--bg);
            border: 1px solid var(--border);
            color: var(--text);
            border-radius: 20px;
            font-size: 14px;
            font-family: inherit;
        }
        
        .chat-input:focus {
            outline: none;
            border-color: var(--accent);
        }
        
        .chat-send-btn {
            padding: 10px 20px;
            background: var(--accent);
            color: white;
            border: none;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
            font-family: inherit;
            transition: background 0.2s;
        }
        
        .chat-send-btn:hover {
            background: var(--accent-hover);
        }

        /* Tab Button Styles */
        .tab-button {
            background: transparent;
            color: var(--text);
            border: none;
            border-bottom: 3px solid transparent;
            padding: 12px 32px;
            font-size: 22px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin: 0 4px;
            transition: all 0.2s ease;
            position: relative;
            border-radius: 4px 4px 0 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .tab-button:hover {
            background: rgba(122, 140, 122, 0.1);
            border-bottom-color: var(--accent);
            color: var(--accent);
        }

        .tab-button.active {
            background: var(--surface);
            color: var(--text);
            border-bottom-color: var(--accent);
            font-weight: 600;
        }

        /* Input Styles */
        .form-input {
            width: 100%;
            padding: 12px;
            background: var(--bg);
            border: 2px solid var(--text);
            color: var(--text);
            font-size: 24px;
            margin-bottom: 16px;
        }

        .form-input:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 5px var(--accent);
        }

        /* Label Styles */
        .form-label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: var(--text);
        }

        /* Button Styles */
        .submit-button {
            background: var(--accent);
            color: var(--bg);
            border: 2px solid var(--accent);
            padding: 12px 24px;
            font-size: 24px;
            cursor: pointer;
            text-transform: uppercase;
            letter-spacing: 1px;
            width: 100%;
            transition: all 0.2s ease;
        }

        .submit-button:hover {
            background: var(--accent-hover);
            box-shadow: 0 0 8px var(--accent);
        }

        /* Message Styles */
        .form-message {
            margin-top: 16px;
            padding: 8px;
            text-align: center;
            font-size: 20px;
            transition: all 0.3s ease;
        }

        .form-message.error {
            color: var(--error);
            font-weight: 500;
        }

        .form-message.success {
            color: var(--success);
            font-weight: 500;
        }

        .form-message.loading {
            color: var(--accent);
            font-style: italic;
        }

        .form-message.loading::after {
            content: '';
            animation: dots 1.5s steps(4, end) infinite;
        }

        /* Chat Input Styles */
        #chat-input:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 3px var(--accent);
        }

        @keyframes dots {
            0%, 20% { content: ''; }
            40% { content: '.'; }
            60% { content: '..'; }
            80%, 100% { content: '...'; }
        }
    </style>
</head>

<body>
    <!-- Game Grid -->
    <div id="game-grid-overlay" class="game-grid-overlay">
        <div id="game-grid" class="game-grid"></div>
    </div>

    <!-- UI Components Container -->
    <div id="ui-container"></div>

    <script>
        // ===============================================================
        // SIMPLE GRID UI SYSTEM
        // ===============================================================

        // Grid state
        let gridState = {
            cols: 0,
            rows: 0,
            cellWidthPx: 0,
            cellHeightPx: 0,
            initialized: false
        };

        // UI Component Registry
        const components = new Map();

        class SimpleGridUI {
            constructor() {
                this.nextId = 1;
            }

            // Create any HTML element with grid positioning
            create(html, x, y, width, height, parent = null) {
                const component = {
                    id: `ui-${this.nextId++}`,
                    html: html,
                    x: x,
                    y: y,
                    width: width,
                    height: height,
                    parent: parent,
                    level: parent ? components.get(parent)?.level + 1 : 0,
                    children: [],
                    dynamicPosition: { // Support for dynamic positioning
                        x: typeof x === 'string',
                        y: typeof y === 'string'
                    }
                };

                // Create element from HTML
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = html;
                const element = tempDiv.firstElementChild;
                
                element.id = component.id;
                // Preserve original classes while adding UI component classes
                const originalClasses = element.className || '';
                element.className = `${originalClasses} ui-component ui-level-${component.level}`;

                // Apply positioning using unified method
                this.applyPositioning(element, component);

                // Store element reference for later access
                component.element = element;

                // Add to DOM - attach to parent if exists, otherwise main container
                let targetParent;
                if (parent) {
                    const parentComp = components.get(parent);
                    targetParent = parentComp ? parentComp.element : document.getElementById('ui-container');
                } else {
                    targetParent = document.getElementById('ui-container');
                }
                
                targetParent.appendChild(element);

                // Register component
                components.set(component.id, component);

                // Add to parent's children
                if (parent) {
                    const parentComp = components.get(parent);
                    if (parentComp) {
                        parentComp.children.push(component.id);
                    }
                }

                console.log('Created component:', component);
                return component.id;
            }

            // Calculate absolute position considering parent hierarchy
            calculateAbsolutePosition(component) {
                let parentX = 0;
                let parentY = 0;
                let parent = component.parent;

                // Walk up parent chain to get parent's absolute position
                while (parent) {
                    const parentComp = components.get(parent);
                    if (parentComp) {
                        // Add parent's position to accumulate total offset
                        if (typeof parentComp.x === 'string') {
                            parentX += this.calculateGridPosition(parentComp.x, parentComp, 'x');
                        } else {
                            parentX += Math.round(parentComp.x * gridState.cellWidthPx);
                        }
                        
                        if (typeof parentComp.y === 'string') {
                            parentY += this.calculateGridPosition(parentComp.y, parentComp, 'y');
                        } else {
                            parentY += Math.round(parentComp.y * gridState.cellHeightPx);
                        }
                        
                        parent = parentComp.parent;
                    } else {
                        break;
                    }
                }

                // Calculate child's position relative to parent
                let childX, childY;
                if (typeof component.x === 'string') {
                    childX = Math.round(this.calculateGridPosition(component.x, component, 'x'));
                } else {
                    childX = Math.round(component.x * gridState.cellWidthPx);
                }
                
                if (typeof component.y === 'string') {
                    childY = Math.round(this.calculateGridPosition(component.y, component, 'y'));
                } else {
                    childY = Math.round(component.y * gridState.cellHeightPx);
                }
                
                const pixelWidth = Math.round(this.calculateGridPosition(component.width, component, 'width'));
                const pixelHeight = Math.round(this.calculateGridPosition(component.height, component, 'height'));

                return {
                    x: parentX + childX,
                    y: parentY + childY,
                    width: pixelWidth,
                    height: pixelHeight
                };
            }

            // Update component position
            update(componentId, x, y, width, height) {
                const component = components.get(componentId);
                if (!component) return;

                // Update dynamic position flags
                component.dynamicPosition.x = typeof x === 'string';
                component.dynamicPosition.y = typeof y === 'string';

                component.x = x || component.x;
                component.y = y || component.y;
                component.width = width || component.width;
                component.height = height || component.height;

                // Update element
                const element = component.element || document.getElementById(componentId);
                if (element) {
                    this.applyPositioning(element, component);
                }

                // Update children (recursive)
                component.children.forEach(childId => {
                    this.update(childId); // Children keep relative positions
                });
            }

            // Apply correct positioning to element
            applyPositioning(element, component) {
                // All components use absolute positioning
                const absPos = this.calculateAbsolutePosition(component);
                element.style.position = 'fixed';
                element.style.left = `${absPos.x}px`;
                element.style.top = `${absPos.y}px`;
                element.style.width = `${absPos.width}px`;
                element.style.height = `${absPos.height}px`;
            }

            // Get component by ID
            get(id) {
                return components.get(id);
            }

            // Remove component
            remove(componentId) {
                const component = components.get(componentId);
                if (!component) return;

                // Remove children first (recursive)
                [...component.children].forEach(childId => {
                    this.remove(childId);
                });

                // Remove from parent's children
                if (component.parent) {
                    const parent = components.get(component.parent);
                    if (parent) {
                        parent.children = parent.children.filter(id => id !== componentId);
                    }
                }

                // Remove from DOM
                const element = document.getElementById(componentId);
                if (element) {
                    element.remove();
                }

                // Remove from registry
                components.delete(componentId);
            }

            // Get DOM element
            getElement(id) {
                return document.getElementById(id);
            }

            // Re-render all components (when grid changes)
            repositionAll() {
                components.forEach((component, id) => {
                    const element = component.element || document.getElementById(component.id);
                    if (element) {
                        this.applyPositioning(element, component);
                    }
                });
            }

            // Calculate position handling both numeric and dynamic keywords
            calculateGridPosition(value, component, dimension) {
                if (typeof value === 'string') {
                    // Handle size strings like "20x20"
                    if (value.includes('x')) {
                        const [width, height] = value.split('x').map(v => parseInt(v.trim()));
                        if (dimension === 'width') return Math.round(width * gridState.cellWidthPx);
                        if (dimension === 'height') return Math.round(height * gridState.cellHeightPx);
                    }
                    
                    // Handle dynamic positioning keywords
                    switch(value) {
                        case 'center':
                        case 'centered':
                            if (dimension === 'x') {
                                let compWidth;
                                if (component && component.element && component.element.offsetWidth) {
                                    // Use actual rendered width if available
                                    compWidth = component.element.offsetWidth;
                                } else {
                                    compWidth = this.calculateGridPosition(component ? component.width : '20x20', component, 'width');
                                }
                                return Math.round((window.innerWidth - compWidth) / 2); // Center X using exact viewport
                            } else if (dimension === 'y') {
                                let compHeight;
                                if (component && component.element && component.element.offsetHeight) {
                                    // Use actual rendered height if available
                                    compHeight = component.element.offsetHeight;
                                } else {
                                    compHeight = this.calculateGridPosition(component ? component.height : '20x20', component, 'height');
                                }
                                return Math.round((window.innerHeight - compHeight) / 2); // Center Y using exact viewport
                            } else if (dimension === 'width') {
                                return Math.round(20 * gridState.cellWidthPx); // 20 cells wide
                            } else if (dimension === 'height') {
                                return Math.round(20 * gridState.cellHeightPx); // 20 cells high
                            }
                            break;
                        case 'middle':
                            if (dimension === 'y') {
                                return Math.round(window.innerHeight / 2); // Middle of viewport
                            }
                            break;
                    }
                    return 0; // Default fallback
                } else {
                    // Handle numeric grid coordinates
                    return Math.round(value * gridState.cellWidthPx);
                }
            }

        }

        // Initialize Grid System
        function createGrid() {
            const overlay = document.getElementById('game-grid-overlay');
            const grid = document.getElementById('game-grid');
            
            // Use exact viewport dimensions
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;
            
            // Find optimal grid dimensions
            let bestCols, bestRows, bestFit = Infinity;
            
            for (let cols = 10; cols <= 100; cols++) {
                for (let rows = 10; rows <= 50; rows++) {
                    const cellWidth = windowWidth / cols;
                    const cellHeight = windowHeight / rows;
                    const avgSize = (cellWidth + cellHeight) / 2;
                    
                    // Prefer cells around 20px
                    const fitScore = Math.abs(avgSize - 20);
                    
                    if (fitScore < bestFit) {
                        bestFit = fitScore;
                        bestCols = cols;
                        bestRows = rows;
                    }
                }
            }
            
            // Set grid template
            grid.style.gridTemplateColumns = `repeat(${bestCols}, 1fr)`;
            grid.style.gridTemplateRows = `repeat(${bestRows}, 1fr)`;
            grid.style.width = '100vw';
            grid.style.height = '100vh';
            
            // Create cells
            grid.innerHTML = '';
            const totalCells = bestCols * bestRows;
            for (let i = 0; i < totalCells; i++) {
                const cell = document.createElement('div');
                cell.className = 'grid-cell';
                cell.textContent = i % 10 === 0 ? 'â€¢' : '';
                grid.appendChild(cell);
            }
            
            // Update grid state
            gridState.cols = bestCols;
            gridState.rows = bestRows;
            gridState.cellWidthPx = windowWidth / bestCols;
            gridState.cellHeightPx = windowHeight / bestRows;
            gridState.initialized = true;
            
            console.log(`Grid: ${bestCols}x${bestRows} cells, ${gridState.cellWidthPx.toFixed(1)}x${gridState.cellHeightPx.toFixed(1)}px each`);
            

            
            // Reposition all UI components (with small delay for stability)
            if (window.gridUI) {
                setTimeout(() => {
                    window.gridUI.repositionAll();
                }, 50);
            }
        }

        // ===============================================================
        // SESSION MANAGEMENT
        // ===============================================================

        function isAuthenticated() {
            const token = localStorage.getItem('authToken');
            const loginTime = localStorage.getItem('loginTime');
            
            if (!token || !loginTime) return false;
            
            // Check if token is older than 24 hours
            const tokenAge = Date.now() - parseInt(loginTime);
            const maxAge = 24 * 60 * 60 * 1000; // 24 hours in milliseconds
            
            return tokenAge < maxAge;
        }

        function getCurrentUser() {
            if (!isAuthenticated()) return null;
            
            return {
                username: localStorage.getItem('username'),
                token: localStorage.getItem('authToken'),
                loginTime: parseInt(localStorage.getItem('loginTime'))
            };
        }

        function clearSession() {
            localStorage.removeItem('authToken');
            localStorage.removeItem('username');
            localStorage.removeItem('loginTime');
        }

        // ===============================================================
        // UI STATE MANAGEMENT
        // ===============================================================

        function showAuthenticationState() {
            const authContainer = document.getElementById('auth-container');
            
            // Make auth container visible
            authContainer.style.display = 'block';
            
            // Show tabs container if it exists
            const tabsContainer = authContainer.querySelector('.tab-container');
            if (tabsContainer) {
                tabsContainer.style.display = 'flex';
            }
            
            // Show authentication forms
            showLoginForm();
        }

        function showAuthenticatedState() {
            const user = getCurrentUser();
            if (!user) {
                showAuthenticationState();
                return;
            }
            
            // Hide auth container
            const authContainer = document.getElementById('auth-container');
            authContainer.style.display = 'none';
            
            // Create or show authenticated container
            let authenticatedContainer = document.getElementById('authenticated-container');
            let authenticatedView = document.getElementById('authenticated-view');
            
            if (!authenticatedContainer) {
                authenticatedContainer = document.createElement('div');
                authenticatedContainer.className = 'auth-container auth-authenticated';
                authenticatedContainer.id = 'authenticated-container';
                document.body.appendChild(authenticatedContainer);
            }
            
            // Always ensure the authenticated view exists
            if (!authenticatedView) {
                authenticatedView = document.createElement('div');
                authenticatedView.id = 'authenticated-view';
                authenticatedView.style.cssText = `
                    grid-column: 2 / 18;
                    grid-row: 2 / 18;
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    justify-content: flex-start;
                    text-align: center;
                    padding-top: 20px;
                `;
                authenticatedContainer.appendChild(authenticatedView);
            }
            
            // Make sure the container and view are visible
            authenticatedContainer.style.display = 'block';
            authenticatedView.style.display = 'flex';
            
            // Calculate login duration
            const loginTime = new Date(user.loginTime);
            const duration = Math.floor((Date.now() - user.loginTime) / 60000); // minutes
            
            authenticatedView.innerHTML = `
                <div class="chat-ui">
                    <div class="chat-header">
                        <span>Logged in as <strong>${user.username}</strong> (${duration} min${duration !== 1 ? 's' : ''})</span>
                        <button class="chat-logout-btn" onclick="handleLogout()">
                            Logout
                        </button>
                    </div>
                    <div class="chat-messages" id="chat-messages">
                        <div class="chat-message system">
                            <span class="content">Welcome, ${user.username}! You can now chat with other logged-in users.</span>
                            <span class="timestamp">${formatTime(Date.now())}</span>
                        </div>
                    </div>
                    <div class="chat-input-container">
                        <input type="text" id="chat-input" class="chat-input" 
                               placeholder="Type a message or command..." 
                               onkeypress="handleChatInput(event)">
                        <button class="chat-send-btn" onclick="sendCommand()">
                            Send
                        </button>
                    </div>
                </div>
            `;
            
            // Start polling for messages
            startPolling();
        }

        function showLoginForm() {
            const tabsContainer = document.querySelector('.tab-container');
            const loginForm = document.getElementById('login-form');
            const registerForm = document.getElementById('register-form');
            const authenticatedView = document.getElementById('authenticated-view');
            
            if (tabsContainer) tabsContainer.style.display = 'flex';
            if (loginForm) loginForm.style.display = 'block';
            if (registerForm) registerForm.style.display = 'none';
            if (authenticatedView) authenticatedView.style.display = 'none';
        }

        // ===============================================================
        // AUTH FUNCTIONS
        // ===============================================================

        function switchTab(tabName) {
            // Update tab buttons
            const loginTab = document.getElementById('login-tab');
            const registerTab = document.getElementById('register-tab');
            
            if (tabName === 'login') {
                loginTab.classList.add('active');
                registerTab.classList.remove('active');
                
                // Show login form, hide register form
                document.getElementById('login-form').style.display = 'block';
                document.getElementById('register-form').style.display = 'none';
            } else {
                loginTab.classList.remove('active');
                registerTab.classList.add('active');
                
                // Show register form, hide login form
                document.getElementById('login-form').style.display = 'none';
                document.getElementById('register-form').style.display = 'block';
            }
        }

        function showMessage(formId, message, isError = false, isLoading = false) {
            const messageElement = document.getElementById(`${formId}-message`);
            if (messageElement) {
                messageElement.textContent = message;
                
                // Remove all state classes first
                messageElement.classList.remove('error', 'success', 'loading');
                
                // Add appropriate class
                if (isLoading) {
                    messageElement.classList.add('loading');
                } else if (isError) {
                    messageElement.classList.add('error');
                } else {
                    messageElement.classList.add('success');
                }
            }
        }

        async function handleLogin() {
            const username = document.getElementById('username-input').value;
            const password = document.getElementById('password-input').value;
            
            if (!username || !password) {
                showMessage('login', 'Please fill in all fields', true);
                return;
            }
            
            try {
                showMessage('login', 'Logging in', false, true);
                
                const response = await fetch('http://localhost:3000/login', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ username, password })
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    // Store authentication session
                    localStorage.setItem('authToken', data.token);
                    localStorage.setItem('username', username);
                    localStorage.setItem('loginTime', Date.now());
                    
                    showMessage('login', 'Login successful!', false);
                    console.log('Login successful:', { username, token: data.token });
                    
                    // Show authenticated state after short delay
                    setTimeout(() => showAuthenticatedState(), 1000);
                } else {
                    showMessage('login', data.error || 'Login failed', true);
                    console.error('Login failed:', data);
                }
            } catch (error) {
                showMessage('login', 'Network error - please try again', true);
                console.error('Login error:', error);
            }
        }

        async function handleRegister() {
            const username = document.getElementById('reg-username-input').value;
            const password = document.getElementById('reg-password-input').value;
            
            if (!username || !password) {
                showMessage('register', 'Please fill in all fields', true);
                return;
            }
            
            if (username.length < 3) {
                showMessage('register', 'Username must be at least 3 characters', true);
                return;
            }
            
            if (password.length < 6) {
                showMessage('register', 'Password must be at least 6 characters', true);
                return;
            }
            
            try {
                showMessage('register', 'Registering', false, true);
                
                const response = await fetch('http://localhost:3000/register', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ username, password })
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    showMessage('register', 'Registration successful! You can now login.', false);
                    console.log('Registration successful:', { username });
                    
                    // Switch to login tab after successful registration
                    setTimeout(() => {
                        switchTab('login');
                        // Clear registration form
                        document.getElementById('reg-username-input').value = '';
                        document.getElementById('reg-password-input').value = '';
                    }, 1500);
                } else {
                    showMessage('register', data.error || 'Registration failed', true);
                    console.error('Registration failed:', data);
                }
            } catch (error) {
                showMessage('register', 'Network error - please try again', true);
                console.error('Registration error:', error);
            }
        }

        async function handleLogout() {
            const user = getCurrentUser();
            
            try {
                // Call logout endpoint with token
                const response = await fetch('http://localhost:3000/logout', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${user.token}`
                    }
                });
                
                const data = await response.json();
                
                if (response.ok) {
                    console.log('Logout successful:', data);
                } else {
                    console.warn('Logout server error:', data);
                }
            } catch (error) {
                console.warn('Logout network error:', error);
            }
            
            // Stop polling and update status to offline
            stopPolling();
            lastProcessedMessageIds.clear();
            onlineUsers.clear();
            
            // Always clear local session regardless of server response
            clearSession();
            
            // Hide authenticated container and show auth container
            const authenticatedContainer = document.getElementById('authenticated-container');
            if (authenticatedContainer) {
                authenticatedContainer.style.display = 'none';
            }
            showAuthenticationState();
            
            // Clear login form inputs for fresh login display
            const usernameInput = document.getElementById('username-input');
            const passwordInput = document.getElementById('password-input');
            if (usernameInput) usernameInput.value = '';
            if (passwordInput) passwordInput.value = '';
            
            showMessage('login', 'Logged out successfully', false);
        }

        // ===============================================================
        // AUTH INTERFACE CREATION - CSS GRID VERSION
        // ==============================================================

        function createAuthInterfaceCSS() {
            // Create unauthenticated container directly in DOM with CSS Grid
            const authContainer = document.createElement('div');
            authContainer.className = 'auth-container auth-unauthenticated';
            authContainer.id = 'auth-container';
            document.body.appendChild(authContainer);
            
            // Create tabs container
            const tabsContainer = document.createElement('div');
            tabsContainer.className = 'tab-container';
            tabsContainer.style.cssText = `
                grid-column: 2 / 20;
                grid-row: 3 / 5;
                display: flex;
                justify-content: center;
                gap: 2px;
                border-bottom: 2px solid var(--text);
                padding-bottom: 0;
            `;
            authContainer.appendChild(tabsContainer);
            
            // Create login tab button
            const loginTab = document.createElement('button');
            loginTab.className = 'tab-button active';
            loginTab.id = 'login-tab';
            loginTab.textContent = 'Login';
            loginTab.onclick = () => switchTab('login');
            tabsContainer.appendChild(loginTab);
            
            // Create register tab button
            const registerTab = document.createElement('button');
            registerTab.className = 'tab-button';
            registerTab.id = 'register-tab';
            registerTab.textContent = 'Register';
            registerTab.onclick = () => switchTab('register');
            tabsContainer.appendChild(registerTab);
            
            // Create login form
            const loginForm = document.createElement('div');
            loginForm.id = 'login-form';
            loginForm.innerHTML = `
                <label class="form-label">Username</label>
                <input type="text" class="form-input" id="username-input" placeholder="Enter your username">
                <label class="form-label">Password</label>
                <input type="password" class="form-input" id="password-input" placeholder="Enter your password">
                <button class="submit-button" onclick="handleLogin()">Login</button>
                <div class="form-message" id="login-message"></div>
            `;
            loginForm.style.cssText = `
                grid-column: 2 / 18;
                grid-row: 6 / 16;
            `;
            authContainer.appendChild(loginForm);
            
            // Create register form (hidden initially)
            const registerForm = document.createElement('div');
            registerForm.id = 'register-form';
            registerForm.style.display = 'none';
            registerForm.innerHTML = `
                <label class="form-label">Username</label>
                <input type="text" class="form-input" id="reg-username-input" placeholder="Choose a username (3+ chars)">
                <label class="form-label">Password</label>
                <input type="password" class="form-input" id="reg-password-input" placeholder="Choose a password (6+ chars)">
                <button class="submit-button" onclick="handleRegister()">Register</button>
                <div class="form-message" id="register-message"></div>
            `;
            registerForm.style.cssText = `
                grid-column: 2 / 18;
                grid-row: 6 / 16;
            `;
            authContainer.appendChild(registerForm);
        }

        // ===============================================================
        // CHAT FUNCTIONS
        // ==============================================================

        function handleChatInput(event) {
            if (event.key === 'Enter') {
                event.preventDefault();
                sendCommand();
            }
        }

        // Message tracking and polling
        let lastProcessedMessageIds = new Set();
        let pollingInterval = null;
        let onlineUsers = new Set();
        let lastCleanup = Date.now();
        let isPolling = false;

        function sendCommand() {
            const input = document.getElementById('chat-input');
            const text = input.value.trim();
            
            if (!text) return;
            
            input.value = '';
            
            const user = getCurrentUser();
            
            // Handle commands (start with /)
            if (text.startsWith('/')) {
                handleCommand(text, user);
            } else {
                // Send as regular message
                sendMessage(text, user);
            }
        }

        function handleCommand(command, user) {
            // Handle logout command
            if (command.toLowerCase() === '/logout') {
                addChatMessage('Logging out...', 'system');
                
                setTimeout(() => {
                    handleLogout();
                }, 500);
                return;
            }
            
            // Handle help command
            if (command.toLowerCase() === '/?' || command.toLowerCase() === '/help') {
                addChatMessage('Available commands: /logout, /?, /help', 'system');
                return;
            }
            
            // Add unknown command response
            addChatMessage(`Unknown command: ${command}`, 'system');
        }

        async function sendMessage(text, user) {
            try {
                const message = {
                    id: `${Date.now()}-${user.username}`,
                    username: user.username,
                    message: text,
                    timestamp: Date.now(),
                    type: 'message'
                };
                
                console.log(`[${user.username}] Sending message via atomic append:`, message);
                
                // Use atomic append - Redis handles this atomically without versioning
                const response = await fetch('http://localhost:3000/shared/chat/messages/atomic', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${user.token}`
                    },
                    body: JSON.stringify({
                        operation: 'append',
                        field: 'list',
                        value: message
                    })
                });
                
                console.log(`[${user.username}] Atomic append response status:`, response.status);
                
                if (!response.ok) {
                    const errorData = await response.text();
                    console.error(`[${user.username}] Atomic append error:`, errorData);
                    
                    // Handle rate limiting
                    if (response.status === 429) {
                        const retryData = JSON.parse(errorData);
                        const retryAfter = retryData.retryAfter || 5;
                        addChatMessage(`Rate limited. Retrying in ${retryAfter} seconds...`, 'system');
                        await new Promise(resolve => setTimeout(resolve, retryAfter * 1000));
                        return sendMessage(text, user); // Retry after delay
                    }
                    
                    throw new Error(`Failed to send message: ${response.status} - ${errorData}`);
                }
                
                const responseData = await response.json();
                console.log(`[${user.username}] Atomic append response data:`, responseData);
                
                // Add to local display immediately for better UX
                addChatMessage(text, 'user', user.username);
                
            } catch (error) {
                console.error('Error sending message:', error);
                addChatMessage('Failed to send message', 'system');
            }
        }

        async function getMessages() {
            const user = getCurrentUser();
            if (!user) return [];
            
            try {
                console.log(`[${user.username}] Getting messages from atomic list`);
                
                // Try GET on the atomic list key directly
                const response = await fetch('http://localhost:3000/shared/chat/messages/list', {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${user.token}`
                    }
                });
                
                if (!response.ok) {
                    // Fallback to regular GET
                    console.log(`[${user.username}] Fallback to regular GET`);
                    const fallbackResponse = await fetch('http://localhost:3000/shared/chat/messages', {
                        method: 'GET',
                        headers: {
                            'Authorization': `Bearer ${user.token}`
                        }
                    });
                    
                    if (!fallbackResponse.ok) {
                        throw new Error('Failed to get messages');
                    }
                    
                    const data = await fallbackResponse.json();
                    console.log(`[${user.username}] Fallback response:`, data);
                    
                    let messages = [];
                    if (data.value) {
                        if (Array.isArray(data.value)) {
                            messages = data.value;
                        } else if (data.value.list) {
                            messages = data.value.list;
                        }
                    }
                    
                    console.log(`[${user.username}] Fallback messages:`, messages);
                    return messages;
                }
                
                const data = await response.json();
                console.log(`[${user.username}] Atomic list response:`, data);
                
                let messages = [];
                if (data.value) {
                    messages = Array.isArray(data.value) ? data.value : [];
                }
                
                console.log(`[${user.username}] Parsed messages:`, messages);
                return messages;
                
            } catch (error) {
                console.error('Error getting messages:', error);
                return [];
            }
        }

        async function cleanupOldMessages(messages) {
            const twelveHoursAgo = Date.now() - (12 * 60 * 60 * 1000);
            const oldMessages = messages.filter(msg => msg.timestamp < twelveHoursAgo);
            
            if (oldMessages.length === 0) return;
            
            const user = getCurrentUser();
            if (!user) return;
            
            try {
                // Clean up old messages in batches
                for (const oldMessage of oldMessages) {
                    await fetch('http://localhost:3000/shared/chat/messages/atomic', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${user.token}`
                        },
                        body: JSON.stringify({
                            operation: 'remove',
                            value: oldMessage
                        })
                    });
                }
                
                console.log(`Cleaned up ${oldMessages.length} old messages`);
                
            } catch (error) {
                console.error('Error cleaning up messages:', error);
            }
        }

        async function updateOnlineStatus(isOnline) {
            const user = getCurrentUser();
            if (!user) return;
            
            try {
                if (isOnline) {
                    // Add to online users set
                    await fetch('http://localhost:3000/shared/users/online/atomic', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${user.token}`
                        },
                        body: JSON.stringify({
                            operation: 'addToSet',
                            field: 'users',
                            value: {
                                username: user.username,
                                lastSeen: Date.now()
                            }
                        })
                    });
                } else {
                    // Remove from online users set
                    await fetch('http://localhost:3000/shared/users/online/atomic', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${user.token}`
                        },
                        body: JSON.stringify({
                            operation: 'removeFromSet',
                            field: 'users',
                            value: {
                                username: user.username,
                                lastSeen: Date.now()
                            }
                        })
                    });
                }
            } catch (error) {
                console.error('Error updating online status:', error);
                // Don't let online status errors break messaging
            }
        }
                    await fetch('http://localhost:3000/shared/users/online/atomic', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${user.token}`
                        },
                        body: JSON.stringify({
                            operation: 'addToSet',
                            value: {
                                username: user.username,
                                lastSeen: Date.now()
                            }
                        })
                    });
                } else {
                    // Remove from online users set
                    await fetch('http://localhost:3000/shared/users/online/atomic', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${user.token}`
                        },
                        body: JSON.stringify({
                            operation: 'removeFromSet',
                            value: {
                                username: user.username,
                                lastSeen: Date.now()
                            }
                        })
                    });
                }
            } catch (error) {
                console.error('Error updating online status:', error);
            }
        }

        async function getOnlineUsers() {
            const user = getCurrentUser();
            if (!user) return [];
            
            try {
                const response = await fetch('http://localhost:3000/shared/users/online/users', {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${user.token}`
                    }
                });
                
                if (!response.ok) {
                    // If online users set doesn't exist yet, return just current user
                    return [{ username: user.username }];
                }
                
                const data = await response.json();
                return Array.isArray(data.value) ? data.value : [];
                
            } catch (error) {
                console.error('Error getting online users:', error);
                // Return just current user as fallback
                return [{ username: user.username }];
            }
        }

        async function pollMessages() {
            if (isPolling) return;
            isPolling = true;
            
            try {
                const messages = await getMessages();
                
                // Clean up old messages periodically
                if (Date.now() - lastCleanup > 5 * 60 * 1000) { // Every 5 minutes
                    await cleanupOldMessages(messages);
                    lastCleanup = Date.now();
                }
                
                // Process new messages
                const newMessages = await getMessages();
                newMessages.forEach(message => {
                    if (!lastProcessedMessageIds.has(message.id)) {
                        lastProcessedMessageIds.add(message.id);
                        
                        if (message.type === 'message' && message.username !== getCurrentUser()?.username) {
                            addChatMessage(message.message, 'user', message.username);
                        }
                    }
                });
                
                // Update online users list
                const newOnlineUsers = await getOnlineUsers();
                const currentOnlineSet = new Set(newOnlineUsers.map(u => u.username));
                
                // Detect users who came online
                currentOnlineSet.forEach(username => {
                    if (!onlineUsers.has(username)) {
                        if (username !== getCurrentUser()?.username) {
                            addChatMessage(`${username} came online`, 'system');
                        }
                    }
                });
                
                // Detect users who went offline
                onlineUsers.forEach(username => {
                    if (!currentOnlineSet.has(username)) {
                        if (username !== getCurrentUser()?.username) {
                            addChatMessage(`${username} went offline`, 'system');
                        }
                    }
                });
                
                onlineUsers = currentOnlineSet;
                updateOnlineUsersDisplay();
                
            } catch (error) {
                console.error('Polling error:', error);
                
                // Handle rate limiting in polling
                if (error.message.includes('429')) {
                    const retryAfter = 10; // Wait 10 seconds on rate limit
                    addChatMessage(`Rate limited. Pausing for ${retryAfter} seconds...`, 'system');
                    setTimeout(() => {
                        addChatMessage('Resuming polling...', 'system');
                    }, retryAfter * 1000);
                }
                
                // Continue polling, just retry next time
            } finally {
                isPolling = false;
            }
        }

        function updateOnlineUsersDisplay() {
            const chatHeader = document.querySelector('.chat-header span');
            if (chatHeader) {
                const user = getCurrentUser();
                const duration = user ? Math.floor((Date.now() - user.loginTime) / 60000) : 0;
                const onlineCount = onlineUsers.size - (onlineUsers.has(user?.username) ? 1 : 0);
                chatHeader.textContent = `${user?.username || 'Unknown'} (${onlineCount} online, ${duration} min${duration !== 1 ? 's' : ''})`;
            }
        }

        async function startPolling() {
            if (pollingInterval) {
                clearInterval(pollingInterval);
            }
            
            const user = getCurrentUser();
            if (!user) return;
            
            // Initialise storage if needed
            try {
                const response = await fetch('http://localhost:3000/shared/chat/messages', {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${user.token}`
                    }
                });
                
                if (!response.ok) {
                    // Key doesn't exist, create it as a list
                    await fetch('http://localhost:3000/shared/chat/messages/atomic', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${user.token}`
                        },
                        body: JSON.stringify({
                            operation: 'append',
                            field: 'list',
                            value: {
                                id: 'init',
                                username: 'system',
                                message: 'Chat initialized',
                                timestamp: Date.now(),
                                type: 'system'
                            }
                        })
                    });
                }
            } catch (e) {
                console.error('Error initializing chat storage:', e);
            }
            
            // Update online status
            await updateOnlineStatus(true);
            
            // Poll every 5 seconds to avoid rate limits
            pollingInterval = setInterval(() => {
                pollMessages();
            }, 5000);
        }

        function stopPolling() {
            if (pollingInterval) {
                clearInterval(pollingInterval);
                pollingInterval = null;
            }
            
            // Update online status to offline
            updateOnlineStatus(false);
        }

        function addChatMessage(message, type = 'user', sender = null) {
            const chatMessages = document.getElementById('chat-messages');
            const messageDiv = document.createElement('div');
            messageDiv.className = `chat-message ${type}`;
            
            if (type === 'user' && sender) {
                messageDiv.innerHTML = `
                    <span class="sender">${sender}:</span> 
                    <span class="content">${message}</span>
                    <span class="timestamp">${formatTime(Date.now())}</span>
                `;
            } else {
                messageDiv.innerHTML = `
                    <span class="content">${message}</span>
                    <span class="timestamp">${formatTime(Date.now())}</span>
                `;
            }
            
            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        function formatTime(timestamp) {
            const date = new Date(timestamp);
            return date.toLocaleTimeString('en-US', { 
                hour: '2-digit', 
                minute: '2-digit' 
            });
        }

        // Initialize on page load
        window.addEventListener('load', () => {
            // Initialize grid
            createGrid();
            
            // Create auth interface using CSS Grid
            createAuthInterfaceCSS();
            
            // Check authentication state and show appropriate UI
            if (isAuthenticated()) {
                showAuthenticatedState();
            } else {
                showAuthenticationState();
            }
        });

        // Handle window resize
        window.addEventListener('resize', () => {
            createGrid();
        });
    </script>
</body>
</html>